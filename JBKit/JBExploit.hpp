//
//  JBExploit.hpp
//  JBKit
//
//  Created by tihmstar on 08.01.24.
//

#ifndef JBExploit_hpp
#define JBExploit_hpp

#include "JBOffsets.hpp"
#include "JBTypes.h"

#include <vector>

namespace JBKit {

class JBExploit{
    
public:
    JBExploit();
    virtual ~JBExploit();
    
#pragma mark public exploit init/cleanup
    virtual bool init(JBOffsets offsets) = 0;
    virtual void cleanup() = 0;
    
#pragma mark availability infos
    virtual bool hasRead64() noexcept;
    virtual bool hasRead32() noexcept;
    virtual bool hasWrite64() noexcept;
    virtual bool hasWrite32() noexcept;
    virtual bool hasExecute() noexcept;

#pragma mark primitives
    virtual uint64_t unstable_read64(kptr_t kaddr);
    virtual uint32_t unstable_read32(kptr_t kaddr);
    
    /*
        Args:
            honorSizeLimit:
                if false, a larger read may be performed this can be problematic when (potentially) reading past a page boundry which may cause a panic
        Returns: number of bytes read
     */
    virtual size_t unstable_read_generic(kptr_t kaddr, void *dstbuf, size_t size, bool honorSizeLimit = false);

    virtual void unstable_write64(kptr_t kaddr, uint64_t val);
    virtual void unstable_write32(kptr_t kaddr, uint32_t val);

    /*
        Args:
            honorSizeLimit:
                if false, a larger write may be performed this can be problematic when (potentially) writing past a page boundry which may cause a panic
        Returns: number of bytes written
     */
    virtual size_t unstable_write_generic(kptr_t kaddr, const void *srcbuf, size_t size, bool honorSizeLimit = false);
    
    virtual void unstable_execute(kptr_t kaddr, std::vector<kptr_t> args = {});
};

}


#endif /* JBExploit_hpp */
