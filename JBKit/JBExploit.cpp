//
//  JBExploit.cpp
//  JBKit
//
//  Created by tihmstar on 08.01.24.
//

#include "JBExploit.hpp"
#include "JBMacros.h"

using namespace JBKit;

#pragma mark constructor
JBExploit::JBExploit(){
    //
}

JBExploit::~JBExploit(){
    //
}

#pragma mark public availability infos
bool JBExploit::hasRead64() const noexcept{
    return false;
}

bool JBExploit::hasRead32() const noexcept{
    return false;
}

bool JBExploit::hasWrite64() const noexcept{
    return false;
}

bool JBExploit::hasWrite32() const noexcept{
    return false;
}

bool JBExploit::hasExecute() const noexcept{
    return false;
}

#pragma mark public provide primitives
size_t JBExploit::unstable_read_generic(kptr_t kaddr, void *dstbuf, size_t size, BOOLEAN honorSizeLimit){
    bool hasr64 = hasRead64();
    bool hasr32 = hasRead32();
    size_t didRead = 0;
    uint8_t *dst = (uint8_t*)dstbuf;
    
    retcustomassure(JBException_primitive_unavailable, hasr64 || hasr32, "read is not implemented by the primitive");
    
    if (hasr64) {
        while (size - didRead > sizeof(uint64_t)) {
            uint64_t r = unstable_read64(kaddr + didRead);
            memcpy(&dst[didRead], &r, sizeof(r));
            didRead += sizeof(r);
        }
    }

    if (hasr32) {
        while (size - didRead > sizeof(uint32_t)) {
            uint32_t r = unstable_read32(kaddr + didRead);
            memcpy(&dst[didRead], &r, sizeof(r));
            didRead += sizeof(r);
        }
    }

    if (honorSizeLimit) return didRead;

    //we will perform an overread and return only as much bytes as requested
    size_t reminder = size - didRead;
    
    if (hasr64 && (reminder > sizeof(uint32_t) || !hasr32)) {
        uint64_t r = unstable_read64(kaddr + didRead);
        memcpy(&dst[didRead], &r, reminder);
        didRead += reminder;
    }else if (hasr32){
        
        if (reminder > sizeof(uint32_t)) reminder = sizeof(reminder);

        {
            uint32_t r = unstable_read32(kaddr + didRead);
            memcpy(&dst[didRead], &r, reminder);
            didRead += reminder;
        }
        
        reminder = size - didRead;
        if (reminder > sizeof(uint32_t)) reminder = sizeof(reminder);

        if (reminder){
            uint32_t r = unstable_read32(kaddr + didRead);
            memcpy(&dst[didRead], &r, reminder);
            didRead += reminder;
        }
    }
    
    return didRead;
}

size_t JBExploit::unstable_write_generic(kptr_t kaddr, const void *srcbuf, size_t size, BOOLEAN honorSizeLimit){
    bool hasw64 = hasWrite64();
    bool hasw32 = hasWrite32();
    size_t didWrite = 0;
    const uint8_t *src = (const uint8_t*)srcbuf;
    
    retcustomassure(JBException_primitive_unavailable, hasw64 || hasw32, "write is not implemented by the primitive");
    
    if (hasw64) {
        while (size - didWrite > sizeof(uint64_t)) {
            uint64_t w = 0;
            memcpy(&w, &src[didWrite], sizeof(w));
            unstable_write64(kaddr + didWrite, w);
            didWrite += sizeof(w);
        }
    }
    
    if (hasw32) {
        while (size - didWrite > sizeof(uint64_t)) {
            uint32_t w = 0;
            memcpy(&w, &src[didWrite], sizeof(w));
            unstable_write32(kaddr + didWrite, w);
            didWrite += sizeof(w);
        }
    }
    
    if (honorSizeLimit) return didWrite;

    //we will perform an overwrite with previously read back bytes
    size_t reminder = size - didWrite;

    if (hasw64 && (reminder > sizeof(uint32_t) || !hasw32)) {
        uint64_t w = unstable_read64(kaddr + didWrite);
        memcpy(&w, &src[didWrite], reminder);
        unstable_write64(kaddr + didWrite, w);
        didWrite += reminder;
    }else if (hasw32){
        
        if (reminder > sizeof(uint32_t)) reminder = sizeof(reminder);
        {
            uint32_t w = unstable_read32(kaddr + didWrite);
            memcpy(&w, &src[didWrite], reminder);
            unstable_write32(kaddr + didWrite, w);
            didWrite += reminder;
        }

        reminder = size - didWrite;
        if (reminder > sizeof(uint32_t)) reminder = sizeof(reminder);

        if (reminder) {
            uint32_t w = unstable_read32(kaddr + didWrite);
            memcpy(&w, &src[didWrite], reminder);
            unstable_write32(kaddr + didWrite, w);
            didWrite += reminder;
        }
    }
    
    return didWrite;
}

#pragma mark public
#pragma mark primitives

uint64_t JBExploit::unstable_read64(kptr_t kaddr){
    retcustomerror(JBException_primitive_unavailable, "unstable_read64 is not implemented by the exploit");
}

uint32_t JBExploit::unstable_read32(kptr_t kaddr){
    retcustomerror(JBException_primitive_unavailable, "unstable_read32 is not implemented by the exploit");
}

void JBExploit::unstable_write64(kptr_t kaddr, uint64_t val){
    retcustomerror(JBException_primitive_unavailable, "unstable_write64 is not implemented by the exploit");
}

void JBExploit::unstable_write32(kptr_t kaddr, uint32_t val){
    retcustomerror(JBException_primitive_unavailable, "unstable_write32 is not implemented by the exploit");
}

kptr_t JBExploit::unstable_execute(kptr_t kaddr, callargs_t args){
    retcustomerror(JBException_primitive_unavailable, "unstable_execute is not implemented by the exploit");
}
